pragma language_version 0.19;

import CompactStandardLibrary;

// Swap fee in basis points (e.g. 10 = 0.1%)
export ledger feeBps: Uint<16>;

// Where the accumulated fees are sent (unshielded)
export ledger treasury: Either<ContractAddress, UserAddress>;

// The fee is only charged on the X side
export ledger xRewards: Uint<128>;

// Though this number is available in QualifiedShieldedCoinInfo, we want this to be publicly readable once Midnight/Compact supports cross-contract calls
export ledger xLiquidity: Uint<128>;

export ledger xColor: Bytes<32>;

export ledger yLiquidity: Uint<128>;

export ledger yColor: Bytes<32>;

export ledger lpTotalSupply: Uint<128>;

export ledger lpCirculatingSupply: Uint<128>;

export ledger coins: Map<Uint<8>, QualifiedShieldedCoinInfo>;

// Only initializes the ledger contract state but doesn't yet initialize the liquidity 
constructor(
    f: Uint<16>,
    t: Either<ContractAddress, UserAddress>,
    xc: Bytes<32>, 
    yc: Bytes<32>
) {
    // Fee must be less than 100% (10000 basis points)
    assert(f < 10000, "Fee too high");

    feeBps = disclose(f);
    treasury = disclose(t);
    xRewards = 0;
    xLiquidity = 0;
    xColor = disclose(xc);
    yLiquidity = 0;
    yColor = disclose(yc);
    lpTotalSupply = 0;
    lpCirculatingSupply = 0;
}

// useful for using AMM prices as Oracle feeds directly in other contracts
export circuit getXLiquidity(): Uint<128> {
    return xLiquidity;
}

// useful for using AMM prices as Oracle feeds directly in other contracts
export circuit getYLiquidity(): Uint<128> {
    return yLiquidity;
}

// receive xIn
// receive yIn
// mint and send lpOut to recipient
export circuit initLiquidity(
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(lpCirculatingSupply == 0, "Already initialized");
    assert(lpOut*lpOut <= xIn*yIn, "Too many LP tokens taken");

    // mint and send lp tokens to recipient (shielded)
    lpCirculatingSupply = disclose(lpOut);
    mintShieldedToken(
        getLPTokenName(),
        disclose(lpOut), // 18446744073709551615
        disclose(nonce),
        disclose(recipient)
    );

    createZswapOutput(
        ShieldedCoinInfo{
            disclose(nonce),
            getLPTokenColor(),
            disclose(lpOut)
        },
        recipient
    );

    //// send remaining lp tokens back to contract (unshielded)
    receiveUnshielded(
        getLPTokenColor(),
        lpTotalSupply - lpCirculatingSupply
    );

    const contractAddress = getShieldedContractAddress();

    // send the x liquidity to the contract (unshielded)
    xLiquidity = disclose(xIn);
    const xCoin = ShieldedCoinInfo{
        pad(32, ""),
        xColor,
        xLiquidity
    };
    receiveShielded(xCoin);
    coins.insertCoin(0, xCoin, contractAddress);

    // send the y liquidity to the contract (unshielded)
    yLiquidity = disclose(yIn);
    const yCoin = ShieldedCoinInfo{
        pad(32, ""),
        yColor,
        yLiquidity
    };
    receiveShielded(yCoin);
    coins.insertCoin(1, yCoin, contractAddress);
}

// receive xLiquidity + xIn
// receive yLiquidity + yIn
// receive 
export circuit addLiquidity(
    xCoin: QualifiedShieldedCoinInfo,
    yCoin: QualifiedShieldedCoinInfo,
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(lpCirculatingSupply > 0, "Not yet initialized");

    const xLiquidityAdded = disclose(xIn);
    const yLiquidityAdded = disclose(yIn);

    if (xLiquidityAdded * yLiquidity < yLiquidityAdded * xLiquidity) {
        assert(lpOut * xLiquidity <= xLiquidityAdded * lpCirculatingSupply, "Too many LP tokens taken (bound by xIn)");
    } else {
        assert(lpOut * yLiquidity <= yLiquidityAdded * lpCirculatingSupply, "Too many LP tokens taken (bound by yIn)");
    }

    // send lp tokens to recipient (shielded)
    lpCirculatingSupply = lpCirculatingSupply + disclose(lpOut) as Uint<128>;
    mintShieldedToken(
        getLPTokenName(),
        disclose(lpOut), // 18446744073709551615
        disclose(nonce),
        disclose(recipient)
    );

    // send old+new x liquidity to contract (unshielded)
    xLiquidity = xLiquidity + xLiquidityAdded as Uint<128>;
    createZswapInput(xCoin);
    receiveShielded(
        ShieldedCoinInfo{
            pad(32, ""),
            xColor,
            xLiquidity
        }
    );

    // send old+new y liquidity to contract (unshielded)
    yLiquidity = yLiquidity + yLiquidityAdded as Uint<128>;
    createZswapInput(yCoin);
    receiveShielded(
        ShieldedCoinInfo{
            pad(32, ""),
            yColor,
            yLiquidity
        }
    );
}

export circuit removeLiquidity(
    lpIn: Uint<64>,
    xOut: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(xOut * lpCirculatingSupply <= lpIn * xLiquidity, "Too many X tokens taken");
    assert(yOut * lpCirculatingSupply <= lpIn * yLiquidity, "Too many Y tokens taken");

    // send all lp tokens to contract (unshielded)
    lpCirculatingSupply = lpCirculatingSupply - disclose(lpIn);
    receiveUnshielded(
        getLPTokenColor(),
        lpTotalSupply - lpCirculatingSupply
    );

    // send x tokens to recipient (shielded)
    createZswapOutput(
        ShieldedCoinInfo{
            disclose(nonce),
            xColor,
            disclose(xOut)
        },
        recipient
    );

    // send remaining x liquidity to contract (unshielded)
    xLiquidity = xLiquidity - disclose(xOut);
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            xColor,
            xLiquidity + xRewards as Uint<128>
        }
    );

    // send y tokens to recipient (shielded)
    createZswapOutput(
        ShieldedCoinInfo{
            disclose(nonce),
            yColor,
            disclose(yOut)
        },
        recipient
    );

    // send remaining y liquidity to contract (unshielded)
    yLiquidity = yLiquidity - disclose(yOut);
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            yColor,
            yLiquidity
        }
    );
}

export circuit swapXToY(
    xIn: Uint<64>,
    xFee: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(xFee * 10000 >= xIn * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // send old+new x liquidity to contract (unshielded)
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity + disclose(xIn - xFee) as Uint<128>;
    receiveUnshielded(
        xColor,
        xLiquidity + xRewards as Uint<128>
    );

    // send y tokens to recipient (shielded)
    createZswapOutput(
        ShieldedCoinInfo{
            disclose(nonce),
            yColor,
            disclose(yOut)
        },
        recipient
    );

    // send remaining y liquidity to contract (unshielded)
    yLiquidity = yLiquidity - disclose(yOut);
    receiveUnshielded(
        yColor,
        yLiquidity
    );

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

export circuit swapYToX(
    yIn: Uint<64>,
    xFee: Uint<64>,
    xOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(xFee * (10000 - feeBps) >= xOut * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // send x tokens to recipient (shielded)
    createZswapOutput(ShieldedCoinInfo{
        disclose(nonce),
        xColor,
        disclose(xOut)
    }, recipient);

    // send remaining x liquidity to contract (unshielded)
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity - disclose(xOut + xFee);
    receiveUnshielded(
        xColor,
        xLiquidity + xRewards as Uint<128>
    );

    // send old+new y liquidity to contract (unshielded)
    yLiquidity = yLiquidity + disclose(yIn) as Uint<128>;
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            yColor,
            yLiquidity
        }
    );

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

export circuit rewardTreasury(): [] {
    // send x liquidity to contract (unshielded)
    receiveUnshielded(
        xColor,
        xLiquidity
    );

    // send x reserves to treasury (unshielded
    sendUnshielded(
        xColor,
        xRewards,
        treasury
    );

    xRewards = 0;
}


circuit getLPTokenName(): Bytes<32> {
    return pad(32, "Pulse LP Token");
}

circuit getLPTokenColor(): Bytes<32> {
    return tokenType(getLPTokenName(), kernel.self());
}

circuit getUnshieldedContractAddress(): Either<ContractAddress, UserAddress> {
    return Either<ContractAddress, UserAddress> {
        true,
        kernel.self(),
        UserAddress{bytes: pad(32, "")}
    };
}

circuit getShieldedContractAddress(): Either<ZswapCoinPublicKey, ContractAddress> {
    return Either<ZswapCoinPublicKey, ContractAddress> {
        false,
        ZswapCoinPublicKey{bytes: pad(32, "")},
        kernel.self()
    };
}

circuit calcK(x: Uint<128>, y: Uint<128>): Uint<248> {
    return ((x as Uint<124>) * (y as Uint<124>)) as Uint<248>;
}

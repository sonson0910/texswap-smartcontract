pragma language_version >= 0.18.0;

// the FaucetAMM contract only used mintShieldedToken and receiveShielded
// this essentially combines a Faucet and an AMM, and is OK for testing purposes

import CompactStandardLibrary;

// Swap fee in basis points (e.g. 10 = 0.1%)
export ledger feeBps: Uint<16>;

// The fee is only charged on the X side
export ledger xRewards: Uint<128>;

// Though this number is available in QualifiedShieldedCoinInfo, we want this to be publicly readable once Midnight/Compact supports cross-contract calls
export ledger xLiquidity: Uint<128>;

export ledger yLiquidity: Uint<128>;

export ledger lpCirculatingSupply: Uint<128>;

// Initializes ledger state AND mints initial test tokens to the recipient
// This follows the OpenZeppelin pattern of minting in constructor to avoid callTx complex type issues
constructor(
    f: Uint<16>,
    initialXAmount: Uint<64>,
    initialYAmount: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    xNonce: Bytes<32>,
    yNonce: Bytes<32>
) {
    // Fee must be less than 100% (10000 basis points)
    assert(f < 10000, "Fee too high");

    feeBps = disclose(f);
    xRewards = 0;
    xLiquidity = 0;
    yLiquidity = 0;
    lpCirculatingSupply = 0;

    // Mint initial test tokens to the recipient
    mintShieldedToken(
        getXTokenName(),
        disclose(initialXAmount),
        disclose(xNonce),
        disclose(recipient)
    );

    mintShieldedToken(
        getYTokenName(),
        disclose(initialYAmount),
        disclose(yNonce),
        disclose(recipient)
    );
}

export circuit mintTestTokensX(
    xOut: Uint<64>, 
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    mintShieldedToken(
        getXTokenName(),
        disclose(xOut),
        disclose(nonce),
        disclose(recipient)
    );
}

export circuit mintTestTokensY(
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    mintShieldedToken(
        getYTokenName(),
        disclose(yOut),
        disclose(nonce),
        disclose(recipient)
    );
}

// receive xIn
// receive yIn
// mint and send lpOut to recipient
export circuit initLiquidity(
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(lpCirculatingSupply == 0, "Already initialized");
    assert(lpOut*lpOut <= xIn*yIn, "Too many LP tokens taken");

    // mint and send lp tokens to recipient (shielded)
    lpCirculatingSupply = disclose(lpOut);
    mintShieldedToken(
        getLPTokenName(),
        disclose(lpOut),
        disclose(nonce),
        disclose(recipient)
    );

    // send the x liquidity to the contract
    xLiquidity = disclose(xIn);
    receiveShielded(ShieldedCoinInfo{
        disclose(nonce),
        getXTokenColor(),
        xLiquidity
    });

    // send the y liquidity to the contract
    yLiquidity = disclose(yIn);
    receiveShielded(ShieldedCoinInfo{
        disclose(nonce),
        getYTokenColor(),
        yLiquidity
    });
}

// receive xLiquidity + xIn
// receive yLiquidity + yIn
// receive 
export circuit addLiquidity(
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(lpCirculatingSupply > 0, "Not yet initialized");

    const xLiquidityAdded = disclose(xIn);
    const yLiquidityAdded = disclose(yIn);

    if (xLiquidityAdded * yLiquidity < yLiquidityAdded * xLiquidity) {
        const xLhs = lpOut * xLiquidity;
        const xRhs = xLiquidityAdded * lpCirculatingSupply;
        assert(xLhs <= xRhs, "Too many LP tokens taken (bound by xIn)");
    } else {
        const yLhs = lpOut * yLiquidity;
        const yRhs = yLiquidityAdded * lpCirculatingSupply;
        assert(yLhs <= yRhs, "Too many LP tokens taken (bound by yIn)");
    }

    // send lp tokens to recipient (shielded)
    lpCirculatingSupply = lpCirculatingSupply + disclose(lpOut) as Uint<128>;
    mintShieldedToken(
        getLPTokenName(),
        disclose(lpOut),
        disclose(nonce),
        disclose(recipient)
    );

    // send old+new x liquidity to contract (unshielded)
    xLiquidity = xLiquidity + xLiquidityAdded as Uint<128>;
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            getXTokenColor(),
            xLiquidityAdded
        }
    );

    // send old+new y liquidity to contract (unshielded)
    yLiquidity = yLiquidity + yLiquidityAdded as Uint<128>;
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            getYTokenColor(),
            yLiquidityAdded
        }
    );
}

export circuit removeLiquidity(
    lpIn: Uint<64>,
    xOut: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    const xLhs = xOut * lpCirculatingSupply;
    const xRhs = lpIn * xLiquidity;
    assert(xLhs <= xRhs, "Too many X tokens taken");
    
    const yLhs = yOut * lpCirculatingSupply;
    const yRhs = lpIn * yLiquidity;
    assert(yLhs <= yRhs, "Too many Y tokens taken");

    // send all lp tokens to contract
    lpCirculatingSupply = lpCirculatingSupply - disclose(lpIn);
    receiveShielded(ShieldedCoinInfo{
        disclose(nonce),
        getLPTokenColor(),
        disclose(lpIn)
    });

    // send x tokens to recipient
    xLiquidity = xLiquidity - disclose(xOut);
    mintShieldedToken(
        getXTokenName(),
        disclose(xOut),
        disclose(nonce),
        disclose(recipient)
    );

    // send y tokens to recipient
    yLiquidity = yLiquidity - disclose(yOut);
    mintShieldedToken(
        getYTokenName(),
        disclose(yOut),
        disclose(nonce),
        disclose(recipient)
    );
}

export circuit swapXToY(
    xIn: Uint<64>,
    xFee: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(xFee * 10000 >= xIn * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // send x liquidity to contract
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity + disclose(xIn - xFee) as Uint<128>;
    receiveShielded(ShieldedCoinInfo{
        disclose(nonce),
        getXTokenColor(),
        disclose(xIn)
    });

    // send y tokens to recipient
    yLiquidity = yLiquidity - disclose(yOut);
    mintShieldedToken(
        getYTokenName(),
        disclose(yOut),
        disclose(nonce),
        disclose(recipient)
    );

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

export circuit swapYToX(
    yIn: Uint<64>,
    xFee: Uint<64>,
    xOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
): [] {
    assert(xFee * (10000 - feeBps) >= xOut * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // send x tokens to recipient
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity - disclose(xOut + xFee);
    mintShieldedToken(
        getXTokenColor(),
        disclose(xOut),
        disclose(nonce),
        disclose(recipient)
    );

    // send old+new y liquidity to contract (unshielded)
    yLiquidity = yLiquidity + disclose(yIn) as Uint<128>;
    receiveShielded(
        ShieldedCoinInfo{
            disclose(nonce),
            getYTokenColor(),
            disclose(yIn)
        }
    );

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

circuit getLPTokenName(): Bytes<32> {
    return pad(32, "Pulse LP Token");
}

circuit getXTokenName(): Bytes<32> {
    return pad(32, "Test token X");
}

circuit getXTokenColor(): Bytes<32> {
    return tokenType(getXTokenName(), kernel.self());
}

circuit getYTokenName(): Bytes<32> {
    return pad(32, "Test token Y");
}

circuit getYTokenColor(): Bytes<32> {
    return tokenType(getYTokenName(), kernel.self());
}

circuit getLPTokenColor(): Bytes<32> {
    return tokenType(getLPTokenName(), kernel.self());
}

circuit getUnshieldedContractAddress(): Either<ContractAddress, UserAddress> {
    return Either<ContractAddress, UserAddress> {
        true,
        kernel.self(),
        UserAddress{bytes: pad(32, "")}
    };
}

circuit getShieldedContractAddress(): Either<ZswapCoinPublicKey, ContractAddress> {
    return Either<ZswapCoinPublicKey, ContractAddress> {
        false,
        ZswapCoinPublicKey{bytes: pad(32, "")},
        kernel.self()
    };
}

circuit calcK(x: Uint<128>, y: Uint<128>): Uint<248> {
    return ((x as Uint<124>) * (y as Uint<124>)) as Uint<248>;
}
